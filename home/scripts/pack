#!/usr/bin/env python3

import argparse
import json
import os
import shutil
import subprocess
import sys
import tempfile
from collections import deque
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Deque, Dict, Iterable, List, Optional, Tuple

import requests
from colored import attr, fg
from github import Github
from yaspin import yaspin

PkgConfig = Dict[str, Any]
LockData = Dict[str, Any]

PKG_JSON: Path = Path.home() / "pkg.json"
PKG_LOCK: Path = Path.home() / "pkg.lock"
DEFAULT_INSTALL_DIR: Path = Path.home() / ".local" / "bin"

DIM: str = attr("dim")
GREEN: str = fg("green")
CYAN: str = fg("cyan")
YELLOW: str = fg("yellow")
RED: str = fg("red")
BOLD: str = attr("bold")
RESET: str = attr("reset")

BUILD_LOG_LINES: int = 15


def get_github_client() -> Github:
    """Create an authenticated GitHub client.

    Tries GITHUB_TOKEN env var, then gh CLI, then falls back to unauthenticated.
    """
    token: Optional[str] = os.environ.get("GITHUB_TOKEN")
    if token:
        return Github(token)

    try:
        result: subprocess.CompletedProcess[str] = subprocess.run(
            ["gh", "auth", "token"],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0 and result.stdout.strip():
            return Github(result.stdout.strip())
    except FileNotFoundError:
        pass

    return Github()


def load_pkg_json() -> PkgConfig:
    if not PKG_JSON.exists():
        print(f"  {RED}[F]{RESET} {PKG_JSON} not found", file=sys.stderr)
        sys.exit(1)
    with open(PKG_JSON) as f:
        return json.load(f)


def load_pkg_lock() -> LockData:
    if PKG_LOCK.exists():
        with open(PKG_LOCK) as f:
            return json.load(f)
    return {"packages": {}}


def save_pkg_lock(lock: LockData) -> None:
    with open(PKG_LOCK, "w") as f:
        json.dump(lock, f, indent=2)
        f.write("\n")


def find_asset(assets: Iterable[Any], artifact: Optional[str]) -> Optional[Any]:
    for asset in assets:
        if artifact:
            if asset.name == artifact:
                return asset
        elif asset.name.lower().endswith(".appimage"):
            return asset
    return None


def download_to(resp: requests.Response, dest: Path) -> None:
    with open(dest, "wb") as f:
        for chunk in resp.iter_content(chunk_size=8192):
            f.write(chunk)


def clear_lines(n: int) -> None:
    """Move cursor up n lines and clear everything below."""
    if n > 0:
        sys.stdout.write(f"\033[{n}A\033[J")
        sys.stdout.flush()


def run_build_cmds(cmds: List[str], variables: Dict[str, str], cwd: str) -> None:
    term_cols: int = shutil.get_terminal_size((80, 24)).columns
    max_line_len: int = term_cols - 6

    for i, cmd in enumerate(cmds, 1):
        expanded: str = cmd.format(**variables)
        print(f"  {BOLD}[{i}/{len(cmds)}]{RESET} {expanded}")

        proc: subprocess.Popen[str] = subprocess.Popen(
            expanded,
            shell=True,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )
        assert proc.stdout is not None

        buf: Deque[str] = deque(maxlen=BUILD_LOG_LINES)
        lines_on_screen: int = 0

        try:
            for line in proc.stdout:
                buf.append(line.rstrip("\n"))

                clear_lines(lines_on_screen)

                lines_on_screen = len(buf)
                for buf_line in buf:
                    display: str = buf_line[:max_line_len]
                    sys.stdout.write(f"  {DIM}    {display}{RESET}\n")
                sys.stdout.flush()
        except BaseException:
            proc.terminate()
            proc.wait()
            clear_lines(lines_on_screen)
            raise

        returncode: int = proc.wait()

        clear_lines(lines_on_screen)

        if returncode != 0:
            for buf_line in buf:
                print(f"  {DIM}    {buf_line}{RESET}")
            raise RuntimeError(f"build command failed (exit {returncode}): {expanded}")


def update_package(
    name: str,
    pkg_config: PkgConfig,
    lock: LockData,
    g: Github,
    install_dir: Path,
    force: bool = False,
) -> None:
    repo_name: str = pkg_config["repo"]
    artifact: Optional[str] = pkg_config.get("artifact")
    bin_name: str = pkg_config.get("bin", name)

    print(f"\n{BOLD}{CYAN}── {name} {RESET}{DIM}({repo_name}){RESET}")

    current: Dict[str, Any] = lock.get("packages", {}).get(name, {})
    current_version: str = current.get("version", "none")
    print(f"  {DIM}installed{RESET}  {current_version}")

    repo = g.get_repo(repo_name)
    latest = repo.get_latest_release()
    latest_version: str = latest.tag_name.lstrip("v")
    print(f"  {DIM}latest{RESET}     {latest_version}")

    if current_version == latest_version and not force:
        print(f"  {GREEN}[OK]{RESET} already up to date")
        return

    if artifact == "source":
        download_url: str = latest.tarball_url
        artifact_name: str = f"{name}-{latest_version}.tar.gz"
    else:
        resolved: Optional[str] = (
            artifact.format(version=latest_version) if artifact else None
        )
        asset = find_asset(latest.get_assets(), resolved)
        if not asset:
            kind: str = f"artifact '{resolved}'" if resolved else "appimage"
            print(
                f"  {RED}[F]{RESET} no {kind} found in release assets", file=sys.stderr
            )
            return
        download_url = asset.browser_download_url
        artifact_name = asset.name

    print(f"  {DIM}artifact{RESET}   {artifact_name}")
    answer: str = input(
        f"  {YELLOW}update {name} from {current_version} to {latest_version}? [y/N]{RESET} "
    )
    if answer.lower() != "y":
        print(f"  {YELLOW}[SKIP]{RESET} skipped")
        return

    build_cmds: Optional[List[str]] = pkg_config.get("build_cmds")

    install_dir.mkdir(parents=True, exist_ok=True)

    if build_cmds:
        with tempfile.TemporaryDirectory(prefix=f"pack_{name}_") as tmpdir:
            artifact_path: Path = Path(tmpdir) / artifact_name
            with yaspin(text=f"downloading {artifact_name}...", color="cyan"):
                resp: requests.Response = requests.get(download_url, stream=True)
                resp.raise_for_status()
                download_to(resp, artifact_path)
            print(f"  {GREEN}[OK]{RESET} downloaded {artifact_name}")

            variables: Dict[str, str] = {
                "artifact": str(artifact_path),
                "install_dir": str(install_dir),
                "bin": bin_name,
                "version": latest_version,
                "tmpdir": tmpdir,
            }

            run_build_cmds(build_cmds, variables, cwd=tmpdir)
    else:
        target: Path = install_dir / bin_name
        backup: Path = target.with_suffix(".backup")

        if target.exists():
            target.rename(backup)

        try:
            with yaspin(text=f"downloading {artifact_name}...", color="cyan"):
                resp = requests.get(download_url, stream=True)
                resp.raise_for_status()
                download_to(resp, target)
                target.chmod(0o755)
            print(f"  {GREEN}[OK]{RESET} downloaded {artifact_name}")
        except Exception:
            if backup.exists():
                backup.rename(target)
            raise

        if backup.exists():
            backup.unlink()

    lock.setdefault("packages", {})[name] = {
        "version": latest_version,
        "artifact": artifact_name,
        "repo": repo_name,
        "installed_at": datetime.now(timezone.utc).isoformat(),
        "url": download_url,
    }

    print(f"  {GREEN}[OK]{RESET} installed {name} v{latest_version}")


def cmd_update(args: argparse.Namespace, config: PkgConfig) -> None:
    lock: LockData = load_pkg_lock()
    install_dir: Path = Path(
        config.get("install_dir", str(DEFAULT_INSTALL_DIR))
    ).expanduser()
    packages: Dict[str, PkgConfig] = config.get("packages", {})

    g: Github = get_github_client()
    targets: List[str] = args.packages if args.packages else list(packages.keys())

    for name in targets:
        if name not in packages:
            print(f"  {RED}[F]{RESET} unknown package: {name}", file=sys.stderr)
            continue
        try:
            update_package(name, packages[name], lock, g, install_dir, force=args.force)
        except Exception as e:
            print(f"  {RED}[F]{RESET} {e}", file=sys.stderr)

    save_pkg_lock(lock)


def cmd_list(config: PkgConfig) -> None:
    lock: LockData = load_pkg_lock()
    packages: Dict[str, PkgConfig] = config.get("packages", {})
    lock_pkgs: Dict[str, Any] = lock.get("packages", {})

    for name in packages:
        if name in lock_pkgs:
            info: Dict[str, Any] = lock_pkgs[name]
            ts: str = info.get("installed_at", "unknown")
            print(
                f"  {CYAN}{name}{RESET}: {GREEN}v{info['version']}{RESET}"
                f" {DIM}(installed {ts}){RESET}"
            )
        else:
            print(f"  {CYAN}{name}{RESET}: {DIM}not installed{RESET}")


def cmd_status(config: PkgConfig) -> None:
    lock: LockData = load_pkg_lock()
    packages: Dict[str, PkgConfig] = config.get("packages", {})
    lock_pkgs: Dict[str, Any] = lock.get("packages", {})

    g: Github = get_github_client()

    StatusResult = Tuple[str, str, Optional[str], Optional[Exception]]
    results: List[StatusResult] = []

    with yaspin(text="checking for updates...", color="cyan"):
        for name, pkg_config in packages.items():
            current_version: str = lock_pkgs.get(name, {}).get("version", "none")
            try:
                repo = g.get_repo(pkg_config["repo"])
                latest = repo.get_latest_release()
                latest_version: str = latest.tag_name.lstrip("v")
                results.append((name, current_version, latest_version, None))
            except Exception as e:
                results.append((name, current_version, None, e))

    for name, current, latest, err in results:
        if err:
            print(f"  {RED}[F]{RESET} {name}: {current} {DIM}(error: {err}){RESET}")
        elif current != latest:
            print(
                f"  {YELLOW}[NEW]{RESET} {BOLD}{name}{RESET}:"
                f" {current} {YELLOW}->{RESET} {latest}"
            )
        else:
            print(f"  {GREEN}[OK]{RESET} {name}: {GREEN}{current}{RESET}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Update packages from GitHub releases",
        epilog="""\
package config (~/pkg.json):
  each entry under "packages" supports:
    repo          GitHub owner/repo (required)
    artifact      release asset to download:
                    - omit to auto-detect first .appimage
                    - exact name, e.g. "nvim-linux-x86_64.appimage"
                    - supports {version} templating, e.g. "tmux-{version}.tar.gz"
                    - "source" to download the release source tarball
    bin           name for the installed binary (defaults to package name)
    build_cmds    array of shell commands to run after downloading to /tmp
                  available variables: {artifact} {install_dir} {bin} {version} {tmpdir}

examples:
  pack                      update all packages
  pack update nvim tmux     update specific packages
  pack update -f nvim       force re-download even if up to date
  pack status               check which packages have updates available
  pack list                 show installed versions from the lockfile""",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    sub = parser.add_subparsers(dest="command")

    p_update = sub.add_parser("update", help="download and install latest releases")
    p_update.add_argument(
        "packages", nargs="*", help="packages to update (default: all)"
    )
    p_update.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="re-download even if already up to date",
    )

    sub.add_parser("list", help="show installed packages and versions from ~/pkg.lock")
    sub.add_parser("status", help="check for available updates without installing")

    args: argparse.Namespace = parser.parse_args()
    config: PkgConfig = load_pkg_json()

    if args.command == "update" or args.command is None:
        if args.command is None:
            args.packages = []
            args.force = False
        cmd_update(args, config)
    elif args.command == "list":
        cmd_list(config)
    elif args.command == "status":
        cmd_status(config)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{DIM}aborted{RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"{RED}[F]{RESET} {e}", file=sys.stderr)
        sys.exit(1)
