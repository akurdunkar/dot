#!/usr/bin/env python3

import argparse
import json
import subprocess
import sys
import tempfile
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

import requests
from github import Github

PkgConfig = Dict[str, Any]
LockData = Dict[str, Any]

PKG_JSON: Path = Path.home() / "pkg.json"
PKG_LOCK: Path = Path.home() / "pkg.lock"
DEFAULT_INSTALL_DIR: Path = Path.home() / ".local" / "bin"


def load_pkg_json() -> PkgConfig:
    if not PKG_JSON.exists():
        print(f"error: {PKG_JSON} not found", file=sys.stderr)
        sys.exit(1)
    with open(PKG_JSON) as f:
        return json.load(f)


def load_pkg_lock() -> LockData:
    if PKG_LOCK.exists():
        with open(PKG_LOCK) as f:
            return json.load(f)
    return {"packages": {}}


def save_pkg_lock(lock: LockData) -> None:
    with open(PKG_LOCK, "w") as f:
        json.dump(lock, f, indent=2)
        f.write("\n")


def find_asset(assets: Iterable[Any], artifact: Optional[str]) -> Optional[Any]:
    """Find the release asset to download.

    If artifact is specified, match by exact name.
    Otherwise default to the first .appimage file found.
    """
    for asset in assets:
        if artifact:
            if asset.name == artifact:
                return asset
        elif asset.name.lower().endswith(".appimage"):
            return asset
    return None


def download_to(resp: requests.Response, dest: Path) -> None:
    """Stream a response body to a file."""
    with open(dest, "wb") as f:
        for chunk in resp.iter_content(chunk_size=8192):
            f.write(chunk)


def run_build_cmds(cmds: List[str], variables: Dict[str, str], cwd: str) -> None:
    """Run build commands sequentially, displaying each and its output."""
    for i, cmd in enumerate(cmds, 1):
        expanded: str = cmd.format(**variables)
        print(f"  [{i}/{len(cmds)}] {expanded}")
        result: subprocess.CompletedProcess[str] = subprocess.run(
            expanded,
            shell=True,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )
        if result.stdout.strip():
            for line in result.stdout.strip().splitlines():
                print(f"    {line}")
        if result.returncode != 0:
            raise RuntimeError(
                f"build command failed (exit {result.returncode}): {expanded}"
            )


def update_package(
    name: str,
    pkg_config: PkgConfig,
    lock: LockData,
    g: Github,
    install_dir: Path,
    force: bool = False,
) -> None:
    repo_name: str = pkg_config["repo"]
    artifact: Optional[str] = pkg_config.get("artifact")
    bin_name: str = pkg_config.get("bin", name)

    print(f"\n--- {name} ({repo_name}) ---")

    current: Dict[str, Any] = lock.get("packages", {}).get(name, {})
    current_version: str = current.get("version", "none")
    print(f"  installed: {current_version}")

    repo = g.get_repo(repo_name)
    latest = repo.get_latest_release()
    latest_version: str = latest.tag_name.lstrip("v")
    print(f"  latest:    {latest_version}")

    if current_version == latest_version and not force:
        print("  already up to date")
        return

    if artifact == "source":
        download_url: str = latest.tarball_url
        artifact_name: str = f"{name}-{latest_version}.tar.gz"
    else:
        resolved: Optional[str] = (
            artifact.format(version=latest_version) if artifact else None
        )
        asset = find_asset(latest.get_assets(), resolved)
        if not asset:
            kind: str = f"artifact '{resolved}'" if resolved else "appimage"
            print(f"  error: no {kind} found in release assets", file=sys.stderr)
            return
        download_url = asset.browser_download_url
        artifact_name = asset.name

    print(f"  artifact:  {artifact_name}")
    answer: str = input(
        f"  update {name} from {current_version} to {latest_version}? [y/N] "
    )
    if answer.lower() != "y":
        print("  skipped")
        return

    build_cmds: Optional[List[str]] = pkg_config.get("build_cmds")

    print(f"  downloading {artifact_name}...")
    resp: requests.Response = requests.get(download_url, stream=True)
    resp.raise_for_status()

    install_dir.mkdir(parents=True, exist_ok=True)

    if build_cmds:
        with tempfile.TemporaryDirectory(prefix=f"update_pkg_{name}_") as tmpdir:
            artifact_path: Path = Path(tmpdir) / artifact_name
            download_to(resp, artifact_path)

            variables: Dict[str, str] = {
                "artifact": str(artifact_path),
                "install_dir": str(install_dir),
                "bin": bin_name,
                "version": latest_version,
                "tmpdir": tmpdir,
            }

            run_build_cmds(build_cmds, variables, cwd=tmpdir)
    else:
        target: Path = install_dir / bin_name
        backup: Path = target.with_suffix(".backup")

        if target.exists():
            target.rename(backup)

        try:
            download_to(resp, target)
            target.chmod(0o755)
        except Exception:
            if backup.exists():
                backup.rename(target)
            raise

        if backup.exists():
            backup.unlink()

    lock.setdefault("packages", {})[name] = {
        "version": latest_version,
        "artifact": artifact_name,
        "repo": repo_name,
        "installed_at": datetime.now(timezone.utc).isoformat(),
        "url": download_url,
    }

    print(f"  installed {name} v{latest_version}")


def cmd_update(args: argparse.Namespace, config: PkgConfig) -> None:
    lock: LockData = load_pkg_lock()
    install_dir: Path = Path(
        config.get("install_dir", str(DEFAULT_INSTALL_DIR))
    ).expanduser()
    packages: Dict[str, PkgConfig] = config.get("packages", {})

    g: Github = Github()
    targets: List[str] = args.packages if args.packages else list(packages.keys())

    for name in targets:
        if name not in packages:
            print(f"unknown package: {name}", file=sys.stderr)
            continue
        try:
            update_package(name, packages[name], lock, g, install_dir, force=args.force)
        except Exception as e:
            print(f"  error: {e}", file=sys.stderr)

    save_pkg_lock(lock)


def cmd_list(config: PkgConfig) -> None:
    lock: LockData = load_pkg_lock()
    packages: Dict[str, PkgConfig] = config.get("packages", {})
    lock_pkgs: Dict[str, Any] = lock.get("packages", {})

    for name in packages:
        if name in lock_pkgs:
            info: Dict[str, Any] = lock_pkgs[name]
            ts: str = info.get("installed_at", "unknown")
            print(f"  {name}: v{info['version']} (installed {ts})")
        else:
            print(f"  {name}: not installed")


def cmd_status(config: PkgConfig) -> None:
    lock: LockData = load_pkg_lock()
    packages: Dict[str, PkgConfig] = config.get("packages", {})
    lock_pkgs: Dict[str, Any] = lock.get("packages", {})

    g: Github = Github()

    for name, pkg_config in packages.items():
        current_version: str = lock_pkgs.get(name, {}).get("version", "none")
        try:
            repo = g.get_repo(pkg_config["repo"])
            latest = repo.get_latest_release()
            latest_version: str = latest.tag_name.lstrip("v")
            marker: str = "*" if current_version != latest_version else " "
            print(f"  {marker} {name}: {current_version} -> {latest_version}")
        except Exception as e:
            print(f"    {name}: {current_version} (error checking: {e})")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Update packages from GitHub releases",
        epilog="""\
package config (~/pkg.json):
  each entry under "packages" supports:
    repo          GitHub owner/repo (required)
    artifact      release asset to download:
                    - omit to auto-detect first .appimage
                    - exact name, e.g. "nvim-linux-x86_64.appimage"
                    - supports {version} templating, e.g. "tmux-{version}.tar.gz"
                    - "source" to download the release source tarball
    bin           name for the installed binary (defaults to package name)
    build_cmds    array of shell commands to run after downloading to /tmp
                  available variables: {artifact} {install_dir} {bin} {version} {tmpdir}

examples:
  update_pkg                      update all packages
  update_pkg update nvim tmux     update specific packages
  update_pkg update -f nvim       force re-download even if up to date
  update_pkg status               check which packages have updates available
  update_pkg list                 show installed versions from the lockfile""",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    sub = parser.add_subparsers(dest="command")

    p_update = sub.add_parser("update", help="download and install latest releases")
    p_update.add_argument(
        "packages", nargs="*", help="packages to update (default: all)"
    )
    p_update.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="re-download even if already up to date",
    )

    sub.add_parser("list", help="show installed packages and versions from ~/pkg.lock")
    sub.add_parser("status", help="check for available updates without installing")

    args: argparse.Namespace = parser.parse_args()
    config: PkgConfig = load_pkg_json()

    if args.command == "update" or args.command is None:
        if args.command is None:
            args.packages = []
            args.force = False
        cmd_update(args, config)
    elif args.command == "list":
        cmd_list(config)
    elif args.command == "status":
        cmd_status(config)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\naborted")
        sys.exit(130)
    except Exception as e:
        print(f"error: {e}", file=sys.stderr)
        sys.exit(1)
